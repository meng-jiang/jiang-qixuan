             LAB3pre Work: Processes in an OS Kernel                     DUE: 9-23-2021       Answer questions below. Submit a (text-edit) file to TA	     1. READ List: Chapter 3: 3.1-3.5What's a process? (Page 102) The execution of an image	     Each process is represented by a PROC structure.Read the PROC structure in 3.4.1 on Page 111 and answer the following questions:What's the meaning of:   pid, ppid? __process identifier, parent process identifier___   status? __different process states____   priority? __determines which process gets more CPU time___   event? __every entry occurs in Kernel__   exitCode? __number returned by process created by command line (0 = no error, other = error) __READ 3.5.2 on Process Family Tree. What are the   PROC pointers child, sibling, parent used for? ___Child points to the first child of process______Sibling points to a list of other children of the same parent______Parent points at its parent___	     2. Download samples/LAB3pre/mtx. Run it under Linux.   MTX is a multitasking system. It simulates process operations in a   Unix/Linux kernel, which include              fork, exit, wait, sleep, wakeup, process switching	     /*********** A Multitasking System ************/#include <stdio.h>#include <stdlib.h>#include <string.h>#include "type.h"    // PROC struct and system constants	// global variables:PROC proc[NPROC], *running, *freeList, *readyQueue, *sleepList; running    = pointer to the current running PROCfreeList   = a list of all FREE PROCsreadyQueue = a priority queue of procs that are READY to runsleepList  = a list of SLEEP procs, if any.Run mtx. It first initializes the system, creates an initial process P0.P0 has the lowest priotiry 0, all other processes have priority 1Ater initialization,     P0 forks a child prcoess P1, switch process to run P1.                The display looks like the following-----------------------------------------------------------------------------Welcome to KCW's Multitasking System1. init systemfreeList = [0 0]->[1 0]->[2 0]->[3 0]->[4 0]->[5 0]->[6 0]->[7 0]->[8 0]->NULL2. create initial process P0init complete: P0 running3. P0 fork P1 : enter P1 into readyQueue	     4. P0 switch process to run P1   P0: switch task   proc 0 in scheduler()   readyQueue = [1 1]->[0 0]->NULL   next running = 1   proc 1 resume to body()proc 1 running: Parent=0 childList = NULLfreeList  = [2 0]->[3 0]->[4 0]->[5 0]->[6 0]->[7 0]->[8 0]->NULLreadQueue = [0 0]->NULLsleepList = NULLinput a command: [ps|fork|switch|exit|sleep|wakeup|wait] : ----------------------------------------------------------------------------5.                     COMMANDS:ps     : display procs with pid, ppid, status; same as ps in Unix/Linuxfork   : READ kfork()   on Page 109: What does it do?__creates a child task and enters it into the readyQueue___switch : READ tswitch() on Page 108: What does it do?__implements process context switching, acts as a process switch box__exit   : READ kexit()   on Page 112: What does it do?__terminates process______________________         sleep  : READ ksleep()  on Page 111: What does it do?__lets a process go to sleep____wakeup : READ kwakeup() on Page 112: What does it do?__which wakes up all te processes sleeping on the event value__wait   : READ kwait()   on Page 114: What does it do?__releases ZOMBIE child PROC back to the freeList for reuse__--------------------------------------------------------------------------------------------------- TEST REQUIREMENTS ---------------------------------6. Step 1: test forkWhile P1 running, enter fork: What happens? __move an element from freeList to readyQueue__Enter fork many times;       How many times can P1 fork? __7 times__ WHY? __The freeList only have 7 elements__Enter Control-c to end the program run.7. Step 2: Test sleep/wakeupRun mtx again.While P1 running, fork a child P2;Switch to run P2. Where did P1 go? __P1 is scheduler()__ WHY? __P2 is running (1 PROC at a time) __P2 running : Enter sleep, with a value, e.g.123 to let P2 SLEEP.What happens? __P2 is scheduler()__ WHY? __pid = 2 wnet in sleepList__Now, P1 should be running. Enter wakeup with a value, e.g. 234Did any proc wake up? ___None___ WHY? __not the value used to sleep any PROC__P1: Enter wakeup with 123What happens? __P2 wakeup__ WHY? __correct value is entered__8. Step 3: test child exit/parent wait	     When a proc dies (exit) with a value, it becomes a ZOMBIE, wakeup its parent.Parent may issue wait to wait for a ZOMBIE child, and frees the ZOMBIERun mtx;P1: enter wait; What happens? __P1 wait for ZOMBIE child__ WHY? __find ZOMBIE child and bury him__CASE 1: child exit first, parent wait laterP1: fork a child P2, switch to P2.P2: enter exit, with a value, e.g. 123 ==> P2 will die with exitCode=123.Which process runs now? __P3__ WHY? __P1 is sleep and P2 have been exited__enter ps to see the proc status: P2 status =? __waiting__(P1 still running) enter wait; What happens? __P1 wait for ZOMBIE_child_                   enter ps;   What happened to P2?__runnning__CASE 2: parent wait first, child exit laterP1: enter fork to fork a child P3P1: enter wait;  What happens to P1? __P1 wait for ZOMBIE_child__ WHY? __need to bury ZOMBIE child__P3: Enter exit with a value; What happens? __P3 exits__P1: enter ps;  What's the status of P3? __sleep__ WHY? __Bury all ZOMBIE cild__	     9. Step 4: test Orphans	     When a process with children dies first, all its children become orphans.In Unix/Linux, every process (except P0) MUST have a unique parent.So, all orphans become P1's children. Hence P1 never dies.Run mtx again.P1: fork child P2, Switch to P2.P2: fork several children of its own, e.g. P3, P4, P5 (all in its childList).P2: exit with a value. P1 should be running WHY? __all orphans become P1's children__P1: enter ps to see proc status: which proc is ZOMBIE? ___P2___What happened to P2's children? __waiting to be bury__P1: enter wait; What happens?  __ P1 wait for ZOMBIE_child__P1: enter wait again; What happens? __ P1 wait for ZOMBIE_child__ WHY? __need to bury ZOMBIE child__How to let P1 READY to run again? ___enter wake up value 123___